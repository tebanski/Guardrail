# Proof-of-Concept for Larga vehicle telemetry
# Copyright (c) October 2018 Steven Yap
#
# Licenced under the GNU LGLP v2 license:
#     https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
#
# Based on examples from Mike Tuupola:
#     https://github.com/tuupola/micropython-examples
#


import micropython
import machine
import uio

from time import time as _time
from time import sleep, sleep_ms
from ustruct import pack
from machine import Neopixel as npx
from m5stack import lcd, time, node_id
from mpu9250 import MPU9250, MPU6500, AK8963
from machine import UART, GPS

from os import rename as os_rename
import filemgmt
import tools


# allocate buffer for emergency exceptions
micropython.alloc_emergency_exception_buf(100)

# ------ global constants ------
# enable gps data collection
ENABLE_GPS = False

# maximum number of samples per 9dof data file
MAX_ENTRIES_PER_9DOF_FILE = 0

# maximum number of samples per gps data file
MAX_ENTRIES_PER_GPS_FILE = 0

# maximum number of samples per fused data file
MAX_ENTRIES_PER_FUSE_FILE = 0

# path where to write data files to
DATA_PATH = filemgmt.SOURCE_DIR

# path where to migrate data files
MIGRATE_PATH = filemgmt.TARGET_DIR

# font to use for LCD display
DISPLAY_FONT = lcd.FONT_Default

# type of Larga packet generated by this device
PACKET_TYPE = 4

# format to use for packing 9DOF data for storage and transmission
# PACK_FORMAT_9DOF = "QLLBBdddddddddddd"
PACK_FORMAT_9DOF = "QLLBBfffffffff"

# format to use for packing GPS data for storage and transmission
PACK_FORMAT_GPS = "QLLBBdddd"

# format to use for packing 9DOF and GPS data for storage and transmission
PACK_FORMAT_FUSION = "QLLBBfffffffffdddd"


# report status when transmitting data sets
STATUS_NORMAL = 0x00
STATUS_WARN = 0x01
STATUS_DANGER = 0x02
STATUS_IMPACT = 0x04
STATUS_FALL = 0x08
STATUS_ROLL = 0x10


# ------ global variables ------
# number of entries in the current sensor data file
_FILE_ENTRIES_9DOF = 0

# number of entries in the current gps data file
_FILE_ENTRIES_GPS = 0

# number of entries in the current fused data file
_FILE_ENTRIES_FUSE = 0

# global file handle for currently-opened sensor log file
_FH_9DOF = None

# global file handle for currently-opened gps receiver log file
_FH_GPS = None

# global file handle for currently-opened fused log file
_FH_FUSE = None

# filename of currently active sensor log file
_LOG_NAME_9DOF = None

# filename of currently active gps receiver log file
_LOG_NAME_GPS = None

# filename of currently active fused log file
_LOG_NAME_FUSE = None


# ------ global (static) object instances ------
# global 6DoF sensor reference
__SENSOR = None
__I2C = None

# global GPS I2C interface reference
__GPS = None
__UART = None

# global real-time clock
__RTC = machine.RTC()

# global timer instances to use
__TIMER_COLLECT = machine.Timer(0)
__TIMER_LOCATE = machine.Timer(1)
__TIMER_MIGRATE = machine.Timer(2)

# global Neopixel instance reference
__NPX = None



def get_unit_tag(file_path="unit.tag"):
  # short-circuit for now
  return int(node_id, 16)


def get_org_tag(file_path="org.tag"):
  # short-circuit for now
  return 1


def init_lcd():
  tools.printmesg("INFO: Initializing LCD screen.")
  lcd.init(
      lcd.M5STACK, width=240, height=320, rst_pin=33, backl_pin=32,
      miso=19, mosi=23, clk=18, cs=14, dc=27, bgr=True, backl_on=1)
  lcd.clear()
  lcd.setCursor(0, 0)
  lcd.setColor(lcd.ORANGE)


def init_ledbar():
  global __NPX

  # tools.printmesg("INFO: Initializing Neopixel device.")
  __NPX = npx(machine.Pin(15), 24)
  __NPX.clear()


def shutdown_ledbar():
  if __NPX:
    # tools.printmesg("INFO: Shutting down Neopixel device.")
    __NPX.clear()
    __NPX.deinit()


def init_sensor():
  global __SENSOR
  global __I2C

  # tools.printmesg("INFO: Initializing 9DOF sensor.")
  print("INFO: Initializing 9DOF sensor.")
  __I2C = machine.I2C(scl=machine.Pin(22), sda=machine.Pin(21), speed=400000)
  mpu6500 = MPU6500(__I2C)
  ak8963 = AK8963(__I2C)
  __SENSOR = MPU9250(__I2C, mpu6500=mpu6500, ak8963=ak8963)


def shutdown_sensor():
  if __SENSOR:
    # tools.printmesg("INFO: Shutting down 6DOF sensor.")
    print("INFO: Shutting down 6DOF sensor.")
    __I2C.deinit()


def init_gps(as_service=True, seed_time=True):
  global __GPS
  global __UART
  global __RTC

  # tools.printmesg("INFO: Initializing GPS receiver.")
  print("INFO: Initializing GPS receiver.")
  __UART = UART(2, tx=17, rx=16, baudrate=9600, timeout=60000, buffer_size=1024)
  __UART.init()
  __GPS = GPS(__UART)
  __GPS.init(timeout=60000)
  if as_service:
    __GPS.startservice()
    if seed_time:
      # run through gps data to flush bad records
      sleep_ms(2000)
      _ = [__GPS.getdata() for i in range(100)]
      # tools.set_time_gps(__GPS.getdata()[0])
      time_tuple = __GPS.getdata()[0]
      __RTC.init(time_tuple)
      

def shutdown_gps():
  if __GPS:
    # tools.printmesg("INFO: Shutting down GPS receiver.")
    print("INFO: Shutting down GPS receiver.")
    if __GPS.service():
      __GPS.stopservice()
    try:
      __UART.deinit()
    except ValueError:
      __UART.deinit()


def init_network():
    import m5cloud
    import network
    
    # tools.printmesg("INFO: Initializing WLAN and MQTT services.")
    print("INFO: Initializing WLAN and MQTT services.")
    nic = network.WLAN(network.STA_IF)
    nic.active(True)
    sleep_ms(1000)
    m5cloud.mqtt.start()
    sleep_ms(1000)


def shutdown_network():
    import m5cloud
    import network
    
    # tools.printmesg("INFO: Shutting down MQTT and WLAN services.")
    print("INFO: Shutting down MQTT and WLAN services.")
    m5cloud.mqtt.stop()
    # m5cloud.mqtt.free()
    sleep_ms(1000)
    nic = network.WLAN(network.STA_IF)
    nic.active(False)
    sleep_ms(1000)


def display_splash(filename="/flash/lib/splash.jpg"):
  sleep_ms(2000)
  lcd.clear()
  lcd.image(58, 21, filename)


def activate_ledbar(hue=npx.GREEN, sat=1.0, max_bri=0.5, steps=24,
                    step_delay_ms=60):
  bri_step = max_bri / steps
  bri = 0.0
  for step in range(steps):
    __NPX.clear()
    for led in range(24):
      __NPX.setHSB(led, hue, sat, bri, 1, False)
    bri += bri_step
    __NPX.show()
    sleep_ms(step_delay_ms)


def deactivate_ledbar(hue=npx.GREEN, sat=1.0, max_bri=0.5, steps=24,
                      step_delay_ms=60):
  bri_step = max_bri / steps
  bri = max_bri
  for step in range(steps):
    __NPX.clear()
    for led in range(24):
      __NPX.setHSB(led, hue, sat, bri, 1, False)
    bri -= bri_step
    __NPX.show()
    sleep_ms(step_delay_ms)
  __NPX.clear()


def _create_log_file(file_type, dir_path, fh=None, log_name=None, 
                     max_file_entries=0, retry_limit=3, retry_wait_ms=5):
  # there is already an open log file
  if fh:
    try:
      fh.close()
    except OSError:
      # file may Fhave been inadvertently moved
      # tools.log_WARN("Failed to close log file {0}.".format(log_name))
      print("WARN: Failed to close log file {0}.".format(log_name))
    else:
      # rename the file (add extension) so it can be migrated to the SD card
      try:
        os_rename(log_name, "{0}.dat".format(log_name))
      except OSError:
        # perhaps the file got moved somehow
        # tools.log_WARN("Failed to rename log file {0}.".format(log_name))
        print("WARN: Failed to rename log file {0}.".format(log_name))
  # create the new name for the log file using the current timestamp
  filename = "{0}_{1}_{2}".format(
      int(_time() * 1000000), file_type, max_file_entries)
  new_log_name = "{0}/{1}".format(dir_path, filename)
  print("INFO: Creating log file {0}.".format(new_log_name))
  for retry_count in range(retry_limit):
    try:
      fh = open(new_log_name, "wb")
    except OSError:
      sleep_ms(retry_wait_ms)
      continue
    else:
      print("INFO: Created log file {0}.".format(new_log_name))
      return (fh, new_log_name)
  return (None, None)


def _commit_readings(file_type, data_packet, fh=None, log_name=None,
                     file_entries=0, max_file_entries=0, retry_limit=3,
                     retry_wait_ms=5):
  if file_entries >= max_file_entries:
    mesg = ("INFO: Current log file {0} already has {1} entries. " + \
            "Closing and creating new log file.")
    print(mesg.format(log_name, file_entries))
    if file_type == "9DOF":
      is_created = create_9dof_log_file(
          retry_limit=retry_limit, retry_wait_ms=retry_wait_ms)
      fh = _FH_9DOF
    elif file_type == "GPS":
      is_created = create_gps_log_file(
          retry_limit=retry_limit, retry_wait_ms=retry_wait_ms)
      fh = _FH_GPS
    elif file_type == "FUSE":
      is_created = create_fuse_log_file(
          retry_limit=retry_limit, retry_wait_ms=retry_wait_ms)
      fh = _FH_FUSE
    else:
      mesg = "Attempting to write to an unknown file type {0}."
      # tools.log_WARN(mesg.format(file_type))
      print("WARN: " + mesg.format(file_type))
      return(0)
    file_entries = 0
    if not is_created:
      mesg = "Failed to create new log file {0}. Restarting device."
      # tools.log_FATAL(mesg.format(log_name))
      print("FATAL: " + mesg.format(log_name))
      shutdown()
      sleep_ms(5000)
      machine.reset()
  is_flushed = False
  for retry_count in range(retry_limit):
    try:
      fh.write(data_packet)
    except OSError:
      is_flushed = False
      sleep_ms(retry_wait_ms)
      continue
    else:
      fh.flush()
      file_entries += 1
      is_flushed = True
      break
  if not is_flushed:
    # tools.log_WARN("Lost write for log file {0} caught.".format(log_name))
    print("WARN: Lost write for log file {0} caught.".format(log_name))
    # tools.log_DEBUG("Droped packet <{0}>.".format(data_packet))
    print("DEBUG: Droped packet <{0}>.".format(data_packet))
  return file_entries


def _build_9dof_packet(timestamp, dof_sample):
  status = evaluate_readings()
  org_tag = get_org_tag()
  unit_tag = get_unit_tag()
  packet = (
      timestamp, org_tag, unit_tag, PACKET_TYPE, status,
      dof_sample["a"][0], dof_sample["a"][1], dof_sample["a"][2],
      dof_sample["g"][0], dof_sample["g"][1], dof_sample["g"][2],
      dof_sample["m"][0], dof_sample["m"][1], dof_sample["m"][2],)
  return packet


def _build_gps_packet(timestamp, gps_sample):
  status = evaluate_readings()
  org_tag = get_org_tag()
  unit_tag = get_unit_tag()
  packet = (
      timestamp, org_tag, unit_tag, PACKET_TYPE, status,
      gps_sample["lat"], gps_sample["lng"], gps_sample["alt"],
      gps_sample["vel"],)
  return packet


def _build_fuse_packet(timestamp, dof_sample, gps_sample):
  status = evaluate_readings()
  org_tag = get_org_tag()
  unit_tag = get_unit_tag()
  packet = (
      timestamp, org_tag, unit_tag, PACKET_TYPE, status,
      dof_sample["a"][0], dof_sample["a"][1], dof_sample["a"][2],
      dof_sample["g"][0], dof_sample["g"][1], dof_sample["g"][2],
      dof_sample["m"][0], dof_sample["m"][1], dof_sample["m"][2],
      gps_sample["lat"], gps_sample["lng"], gps_sample["alt"],
      gps_sample["vel"],)
  return packet


def create_9dof_log_file(dir_path=DATA_PATH, retry_limit=3, retry_wait_ms=5):
  global _FILE_ENTRIES_9DOF
  global _FH_9DOF
  global _LOG_NAME_9DOF

  (fh, log_name) = _create_log_file(
      "9DOF", dir_path, fh=_FH_9DOF, log_name=_LOG_NAME_9DOF, 
      max_file_entries=MAX_ENTRIES_PER_9DOF_FILE, retry_limit=retry_limit,
      retry_wait_ms=retry_wait_ms)
  if fh:
    _FH_9DOF = fh
    _LOG_NAME_9DOF = log_name
    _FILE_ENTRIES_9DOF = 0
    return True
  return False


def create_gps_log_file(dir_path=DATA_PATH, retry_limit=3,
                        retry_wait_ms=5):
  global _FILE_ENTRIES_GPS
  global _FH_GPS
  global _LOG_NAME_GPS

  (fh, log_name) = _create_log_file(
      "GPS", dir_path, fh=_FH_GPS, log_name=_LOG_NAME_GPS,
      max_file_entries=MAX_ENTRIES_PER_GPS_FILE, retry_limit=retry_limit,
      retry_wait_ms=retry_wait_ms)
  if fh:
    _FH_GPS = fh
    _LOG_NAME_GPS = log_name
    _FILE_ENTRIES_GPS = 0
    return True
  return False


def create_fuse_log_file(dir_path=DATA_PATH, retry_limit=3,
                         retry_wait_ms=5):
  global _FILE_ENTRIES_FUSE
  global _FH_FUSE
  global _LOG_NAME_FUSE

  (fh, log_name) = _create_log_file(
      "FUSE", fh=_FH_FUSE, log_name=_LOG_NAME_FUSE, dir_path=dir_path,
      max_file_entries=MAX_ENTRIES_PER_FUSE_FILE, retry_limit=retry_limit,
      retry_wait_ms=retry_wait_ms)
  if fh:
    _FH_FUSE = fh
    _LOG_NAME_FUSE = log_name
    _FILE_ENTRIES_FUSE = 0
    return True
  return False


def collect_9dof_readings(timer):
  global _FILE_ENTRIES_9DOF
  
  timestamp = int(_time() * 1000000)
  sensor_sample = dict(
      a=__SENSOR.acceleration, g=__SENSOR.gyro, m=__SENSOR.magnetic)
  raw_packet = _build_9dof_packet(timestamp, sensor_sample)
  data_packet = pack(PACK_FORMAT_9DOF, *raw_packet)
  _FILE_ENTRIES_9DOF = _commit_readings(
      "9DOF", data_packet, fh=_FH_9DOF, log_name=_LOG_NAME_9DOF,
      file_entries=_FILE_ENTRIES_9DOF, retry_limit=3, retry_wait_ms=5,
      max_file_entries=MAX_ENTRIES_PER_9DOF_FILE)


def collect_gps_readings(timer):
  global _FILE_ENTRIES_GPS

  timestamp = int(_time() * 1000000)
  (_, _lat, _lng, _alt, _, _, _kph, _, _) = __GPS.getdata()
  receiver_sample = dict(lat=_lat, lng=_lng, alt=_alt, vel=_kph,)
  raw_packet = _build_gps_packet(timestamp, receiver_sample)
  data_packet = pack(PACK_FORMAT_GPS, *raw_packet)
  _FILE_ENTRIES_GPS = _commit_readings(
      "GPS", data_packet, fh=_FH_GPS, log_name=_LOG_NAME_GPS,
      file_entries=_FILE_ENTRIES_GPS, retry_limit=3, retry_wait_ms=5,
      max_file_entries=MAX_ENTRIES_PER_GPS_FILE)


def collect_fuse_readings(timer):
  global _FILE_ENTRIES_FUSE

  timestamp = int(_time() * 1000000)
  (_, _lat, _lng, _alt, _, _, _kph, _, _) = __GPS.getdata()
  sensor_sample = dict(
      a=__SENSOR.acceleration, g=__SENSOR.gyro, m=__SENSOR.magnetic)
  receiver_sample = dict(lat=_lat, lng=_lng, alt=_alt, vel=_kph)
  raw_packet = _build_fuse_packet(timestamp, sensor_sample, receiver_sample)
  data_packet = pack(PACK_FORMAT_FUSION, *raw_packet)
  _FILE_ENTRIES_FUSE = _commit_readings(
      "FUSE", data_packet, fh=_FH_FUSE, log_name=_LOG_NAME_FUSE,
      file_entries=_FILE_ENTRIES_FUSE, retry_limit=3, retry_wait_ms=5,
      max_file_entries=MAX_ENTRIES_PER_FUSE_FILE)


def evaluate_readings():
  return STATUS_NORMAL


def migrate_files(timer):
  status = filemgmt.migrate(
      source_dir=DATA_PATH, target_dir=MIGRATE_PATH)
  if not status:
    # tools.log_FATAL("File migration failed. Restarting device.")
    print("FATAL: File migration failed. Restarting device.")
    shutdown()
    sleep_ms(5000)
    machime.reset()


def _config_global_params(enable_gps=True, sample_window_sec=120,
                          sample_interval_9dof_msec=200,
                          sample_interval_gps_msec=500,
                          sample_interval_fuse_msec=250,
                          data_path=filemgmt.SOURCE_DIR,
                          migrate_path=filemgmt.TARGET_DIR):
  global MAX_ENTRIES_PER_9DOF_FILE
  global MAX_ENTRIES_PER_GPS_FILE
  global MAX_ENTRIES_PER_FUSE_FILE
  global ENABLE_GPS
  global DATA_PATH
  global MIGRATE_PATH

  ENABLE_GPS = enable_gps
  DATA_PATH = data_path
  MIGRATE_PATH = migrate_path
  MAX_ENTRIES_PER_9DOF_FILE = int(
      sample_window_sec * (1000 / sample_interval_9dof_msec))
  MAX_ENTRIES_PER_GPS_FILE = int(
      sample_window_sec * (1000 / sample_interval_gps_msec))
  MAX_ENTRIES_PER_FUSE_FILE = int(
      sample_window_sec * (1000 / sample_interval_fuse_msec))


def init(enable_gps=True, fuse_readings=False, sample_window_sec=120,
         sample_interval_9dof_msec=200, sample_interval_gps_msec=500,
         sample_interval_fuse_msec=250, migrate_interval_msec=300000,
         data_path=filemgmt.SOURCE_DIR, migrate_path=filemgmt.TARGET_DIR):
  """Initializes and start the LARGA vehicle sensor platform.

  Args:
    enable_gps (bool): enable gps data collection
    fuse_readings (bool): combine 9dof and gps readings into one collection
    sample_window (int): amount of time to collect data for each cycle
    sample_interval_9dof_msec (int): data collection frequency for 9dof sensor
    sample_interval_gps_msec (int): data collection frequency for gps receiver
    sample_interval_fuse_msec (int): data collection frequency for fused data
    migrate_interval_msec (int): amount of time to wait before migrating
      log files from flash to SD card
    data_path (str): directory path (on flash) where data collection logs
      are initially written to
    migrate_path (str): directory path (on SD card) where data collection logs
      are moved to
  """
  _config_global_params(
      data_path=data_path, migrate_path=migrate_path,
      enable_gps=enable_gps, sample_window_sec=sample_window_sec,
      sample_interval_9dof_msec=sample_interval_9dof_msec,
      sample_interval_gps_msec=sample_interval_gps_msec,
      sample_interval_fuse_msec=sample_interval_fuse_msec,)

  if filemgmt.mountsd():
    # print("Starting LARGA driver.")
    tools.printmesg("INFO: SD device mounted on /sd.") 
    sleep(2)
    # check to see if the source and target data migration folders exist
    if  filemgmt.check_dir(data_path) \
        and filemgmt.check_dir(migrate_path):
      # move any file found in /flash/__DATA__ to /sd/__DATA__
      mesg = "INFO: Migrating any existing files in {0} to {1}."
      tools.printmesg(mesg.format(data_path, migrate_path))
      filemgmt.migrate_all()
      # create log entry when starting driver services    
      tools.log_START("Starting LARGA driver.")
      # initialize lcd display
      init_lcd()
      # initialize led (neopixel) bar
      init_ledbar()
      # display the splash image
      display_splash()
      sleep_ms(2000)
      if enable_gps:
        shutdown_network()
        sleep_ms(2000)
        init_gps(as_service=True, seed_time=True)
        sleep_ms(2000)
      else:
        tools.set_time_fqdn()
      # initialize 6dof sensor
      init_sensor()
      # activate the led bar
      activate_ledbar()
      # create initial 9dof log file
      print("INFO: Creating initial log files.")
      mesg = "Failed to create new log file {0}. Restarting device." 
      is_9dof_created = create_9dof_log_file()
      sleep_ms(2000)
      if not is_9dof_created:
        # tools.log_FATAL(mesg.format(_LOG_NAME_9DOF))
        print("FATAL: " + mesg.format(_LOG_NAME_9DOF))
        shutdown()
        sleep_ms(5000)
        machine.reset()
      # create initial gps log file
      if enable_gps:
          sleep_ms(2000)
          is_gps_created = create_gps_log_file()
          if not is_gps_created:
            # tools.log_FATAL(mesg.format(_LOG_NAME_GPS))
            print("FATAL: " + mesg.format(_LOG_NAME_GPS))
            shutdown()
            sleep_ms(5000)
            machine.reset()
      # launch data collection timer
      # tools.printmesg("INFO: Starting main event loop.")
      sleep_ms(2000)
      print("INFO: Starting main event loop.")
      if fuse_readings:
        print("Starting fused data collection loop.")
        __TIMER_COLLECT.init(
            period=sample_interval_fuse_msec, mode=machine.Timer.PERIODIC,
            callback=collect_fuse_readings)
      else:
        print("INFO: Starting 9dof data collection loop.")
        __TIMER_COLLECT.init(
            period=sample_interval_9dof_msec, mode=machine.Timer.PERIODIC,
            callback=collect_9dof_readings)
        # launch gps data collection timer
        if enable_gps:
          print("INFO: Starting gps data collection loop.")
          __TIMER_LOCATE.init(
              period=sample_interval_gps_msec, mode=machine.Timer.PERIODIC,
              callback=collect_gps_readings)
        # launch data migration timer
      __TIMER_MIGRATE.init(
          period=migrate_interval_msec, mode=machine.Timer.PERIODIC,
          callback=migrate_files)
      # tools.printmesg("INFO: Initialization complete.")
      print("INFO: Initialization complete.")
      # tools.log_START("Started LARGA driver.")
      print("INFO: Started LARGA driver.")
      return True
    else:
      mesg = "Either {0} or {1} directories were not found."
      tools.log_FATAL(mesg.format(filemgmt.SOURCE_DIR, filemgmt.TARGET_DIR))
  return False


def shutdown():
  lcd.clear()
  # tools.log_STOP("Stopping LARGA driver.")
  print("INFO: Stopping LARGA driver.")
  # tools.printmesg("INFO: Stopping main event loop.")
  print("INFO: Stopping main event loop.")
  # stop data collection timer
  __TIMER_COLLECT.deinit()
  # stop data migration timer
  __TIMER_MIGRATE.deinit()
  mesg = "INFO: Migrating any existing files in {0} to {1}."
  # tools.printmesg(mesg.format(filemgmt.SOURCE_DIR, filemgmt.TARGET_DIR))
  print(mesg.format(filemgmt.SOURCE_DIR, filemgmt.TARGET_DIR))
  # move all remaining files in /flash/__DATA__ into /sd/__DATA__
  filemgmt.migrate_all()
  # stop the 6DF sensor and unregister it from the I2C bus
  shutdown_sensor()
  # power down led bar
  deactivate_ledbar()
  # stop neopixel device and free all used resources
  shutdown_ledbar()
  # restart network stack os gps was enables
  if ENABLE_GPS:
    init_network()
  tools.log_STOP("Stopped LARGA driver.")
  tools.printmesg("INFO: Shutdown complete.")
  return True
